## Трейты

Трейты напоминают классы, экземпляры которых нельзя
получить, но можно включить в другие классы. Поэтому любое свойство
(или метод), определенное в трейте, становится частью того класса, в который включен этот трейт. При этом трейт изменяет структуру данного
класса, но не меняет его тип. (Насколько вы помните, классы и интерфейсы меняют тип).

    Трейты можно назвать переиспользуемым куском кода, "вставка" для класса. (субъективно)

```php
trait PriceUtilities
{
    private $taxrate = 20;
    public function calculateTax(float $price): float
    {
        return (($this->taxrate / 100) * $price);
    }
    // Другие служебные методы
}

class ShopProduct
{
    use PriceUtilities; // используем трейт (весь код трейта в виде одной строки)
}
```

    Можно использовать неограниченное количество трейтов

Можно также совмещать трейты и интерфейсы, если мы хотим задать тип классу. То есть, создать
метод в трейте и такой же в интерфейсе. Теперь, при использовании трейта мы также используем
метод интерфейса. Соотвественно привязываем тип интерфейса классу.

### Конфликты имен. Ключевое слово insteadof.
Если получится так, что два разных трейта содержат метод с одинаковым названием, мы
получим ошибку. Для устранения подобного конфликта используется ключевое слово `insteadof`:

```php
class UtilityService extends Service
{
    use PriceUtilities;
    use TaxTools
    {
        TaxTools::calculateTax insteadof PriceUtilities;
    }
}
```

Теперь при вызове метода `calculateTax()`, будет выполнен метод из трейта `TaxTools`. Одноименный
метод из `PriceUtilities` игнорируется.
